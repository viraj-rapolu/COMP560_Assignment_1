import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.Random;


public class backtracking {
    public static List<State> stateListInput;

    public backtracking(List<State> stateListInput){

        List<State> stateList = stateListInput;
        Queue<State> unassignedStateQ = new LinkedList<>();
        Queue<State> finishedStateQ = new LinkedList<>();
        // When backtracking, reintroduce the color back based on looking at it's available nodes
        // List<State> traversed = new ArrayList<>(); // List of states that have been visited. Might need to replace this with a tree in future

        for (State state : stateList){
            unassignedStateQ.add(state);
        }

        State head = unassignedStateQ.peek(); //take first state
        traversed.add(head);
        finishedStateQ.add(head);
        //mark first state as reached


        //assign a color
        head = randColorAssign(head);
        bool test = ArcConst(stateList, unassignedStateQ, head); // Add the random color to bordering states' broken colors
        if (test) {
            State next = nextState(head);
            bool ArcConst(head)
        }

        // Choose next state to visit

        //create a Queue and pop of the first state at random
        /***assign state a color and update the status of each and every state.  Check to see if any states have a conflict. If not
         place the state in a finished queue. This is for easy reverse traversal if a road block is encountered
         If a road block is encountered (a state has no potential color assignments) assign the state of choice a different color and
         recheck arc consistency.  If a potential color exists, continue. If not pop the previous state of the finished Queue
         and change its color and continue.
         continue until all states are finished
         ***/

        /*** changes to make:
         *  States: need to track what colors a state can potentially have as well as colors it cannot have (both color lists should be updated
         *  Arc Consistency: should check potential color options for all states, making sure each has at least one
         *  good to include recursion
         *
         */






    }

    public State nextState(State state) {
        ArrayList<State> neighbors = state.getBorderStates();

        int borderCount = 0;
        List<State> mostConstraining = new ArrayList<>();
        List<State> leastConstrained = new ArrayList<>();

        int numColors = state.getColorList().size();

        for (State neighbor: neighbors){
            // Check to see if backtrack is necessary. Should we do this here or elsewhere?
            // backtrack(neighbor);

            // Choose states that are least constrained
            if (neighbor.getNumBrokeColors() <= numColors) {
                numColors = neighbor.getNumBrokeColors();
                leastConstrained.add(neighbor);
                // Choose states that are most constraining
                if (neighbor.getBorderStates().size() >= borderCount) {
                    borderCount = neighbor.getBorderStates().size();
                    mostConstraining.add(neighbor);
                }
            }
        }
        // Choose random state from mostConstraining to get next state to move on to
        return mostConstraining.get(0);
    }

    public void backtrack(State state) {

        // Function that checks if a state has all colors broken. If so, do something
    }

    public boolean colorCheck(State head, List<State> statesList) throws CloneNotSupportedException { //actually have to go back and update color list!!!
        String headColor = head.assignedColor;
        List<State> neighborStates= new ArrayList<State>();
        for (String neighborNames : head.borderStates){
            State neighbor = findStateByName(neighborNames, statesList);
            State tmp = (State)((State)neighbor).clone();
            List neighborColors = tmp.colorList;
            if (neighborColors.contains(headColor)){
                neighborColors.remove(headColor);
            }
            if (tmp.getColorList().size()==0){ return true;} //a neighbor has no potential color options so backtrack
        } return false;
    }

    public State randColorAssign(State state){
        List<String> colorList = state.getColorList();
        Random rand = new Random();
        state.assignedColor =  colorList.get(rand.nextInt(colorList.size()));
        return state;
    }

    public boolean ArcConst(List<State> stateList, Queue<State> stateQ, State head){
        ArrayList<State> neighbors = head.getBorderStates();
        //if true, we would update all the neighbor's color lists
        //if false, we would need to assign a different color and crun the colorCheck again
        List<String> colorList;
        colorList = (ArrayList)head.getColorList().clone();

        for(String color: colorList){
            head.assignedColor = color;
            boolean changeColor = colorCheck(head, stateList); // if this bool is true, neighbors have issues, change color
            // check the statelist to see if any of the states have had changes

            if (!changeColor) {

                for (String neighborNames : head.borderStates){
                    String headColor = head.assignedColor;

                    State neighbor = findStateByName(neighborNames, stateList);
                    List neighborColors = neighbor.colorList;
                    if (neighborColors.contains(headColor)){
                        neighborColors.remove(headColor);
                    }
                    if (neighbor.getColorList().size()==0){ return false;
                    // call backtrack
                    } //a neighbor has no potential color options so backtrack
                }

                // update each neighbor's color lists by removing "head"s color

                return true;
            }
        }


        return false;

    }

    public State findStateByName(String name, List<State> states){
        for(State state : states){
            if(state.getName().equals(name)){
                return state;
            }
        }
        return null;
    }
}
